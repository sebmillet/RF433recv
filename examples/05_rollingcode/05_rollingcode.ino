// 05_rollingcode.ino

// Example sketch that comes along with RF433recv library.
// Shows how to handle a case where code analysis is needed.
//
// *IMPORTANT*
//   THIS CODE DOES NOT MANAGE THE ROLLING CODE ASPECT.
//   I'll simply use certain properties of a rolling-code-telecommand, to work
//   out whether the first button was pushed, or the second.

/*
  Copyright 2021, 2022 SÃ©bastien Millet

  `RF433recv' is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as
  published by the Free Software Foundation, either version 3 of the
  License, or (at your option) any later version.

  `RF433recv' is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this program. If not, see
  <https://www.gnu.org/licenses>.
*/

//
// Schematic: Radio Frequencies RECEIVER plugged on D2
//

#include "RF433recv.h"
#include <Arduino.h>

#define PIN_RFINPUT  2
#define INT_RFINPUT  0

//void callback_debug(const BitVector *recorded) {
//    Serial.print(F("Code received: "));
//    char *printed_code = recorded->to_str();

//    if (printed_code) {
//        Serial.print(recorded->get_nb_bits());
//        Serial.print(F(" bits: ["));
//        Serial.print(printed_code);
//        Serial.print(F("]\n"));

//        free(printed_code);
//    }
//}

void button_up_pushed() {
    Serial.print(F("Button up pushed\n"));
}

void button_down_pushed() {
    Serial.print(F("Button down pushed\n"));
}

    // Codes generated by the FLO/R telecommand look like the below:
    //
    //                            X                  X
    //                            |                  |
    //   Code received: 72 bits: [1c 65 8a b0 96 09 88 dd ea] (up pushed)
    //   Code received: 72 bits: [17 03 cd c9 ff 60 e8 99 26] (up pushed)
    //   Code received: 72 bits: [2a e3 88 28 1e 81 08 77 75] (down pushed)
    //   Code received: 72 bits: [18 17 5a 36 e0 7f f8 66 2c] (up pushed)
    //
    // First 'X':
    //   - When the 'up' button us pressed, the first character (high half-byte
    //     value of byte number 9, bytes counted from 1 right to left) is 1.
    //   - When the 'down' button us pressed, the first character (high
    //     half-byte value of byte number 9, bytes counted from 1 right to left)
    //     is 2.
    //
    // Second 'X':
    //   Another characteristic is:
    //   - The low half-byte value of the byte number 3 (bytes counted from 1
    //     right to left) is always 8.
    //
    // As written at the top of this file, we don't check the rolling code
    // itself. So I guess any other telecommand of the same type would produce
    // the same codes. Said differently: we can't identify the telecommand
    // behind. So we could call it 'the rolling code of the (very) poor man'.
void callback(const BitVector *recorded) {

        // Defensive programming
        // register_Receiver() sets the number of bits to 72, so we should
        // always have 72 bits when entering here.
    if (recorded->get_nb_bits() != 72)
        return;

    byte first_half_byte = (recorded->get_nth_byte(8) & 0xF0) >> 4;
    byte my_eigth = (recorded->get_nth_byte(2) & 0x0F);

// Silently ignore codes that don't follow expectations.
// If you want to debug it, use callback_debug instead.

    if (my_eigth != 8)
        return;
    if (first_half_byte == 1)
        button_up_pushed();
    else if (first_half_byte == 2)
        button_down_pushed();
}

RF_manager rf(PIN_RFINPUT, INT_RFINPUT);

void setup() {
    pinMode(PIN_RFINPUT, INPUT);
    Serial.begin(115200);

//    rf.register_Receiver( RFMOD_TRIBIT, 18000, 1450, 1450, 0, 450, 900, 0, 0,
//            1400, 18000, 72, callback_debug, 2000);
    rf.register_Receiver( RFMOD_TRIBIT, 18000, 1450, 1450, 0, 450, 900, 0, 0,
            1400, 18000, 72, callback, 2000);

    Serial.print(F("Waiting for signal\n"));

    rf.set_opt_wait_free_433(true, 1000);
    rf.set_inactivate_interrupts_handler_when_a_value_has_been_received(true);
    rf.activate_interrupts_handler();
}

void loop() {
    rf.do_events();
}

// vim: ts=4:sw=4:tw=80:et
